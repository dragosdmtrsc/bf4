/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "p4_api_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace p4_thrift {

int _kinstruction_typeValues[] = {
  instruction_type::call,
  instruction_type::normal,
  instruction_type::controlled,
  instruction_type::evil,
  instruction_type::nondet,
  instruction_type::param_pass,
  instruction_type::external,
  instruction_type::bug,
  instruction_type::good,
  instruction_type::assume
};
const char* _kinstruction_typeNames[] = {
  "call",
  "normal",
  "controlled",
  "evil",
  "nondet",
  "param_pass",
  "external",
  "bug",
  "good",
  "assume"
};
const std::map<int, const char*> _instruction_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kinstruction_typeValues, _kinstruction_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const instruction_type::type& val) {
  std::map<int, const char*>::const_iterator it = _instruction_type_VALUES_TO_NAMES.find(val);
  if (it != _instruction_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const instruction_type::type& val) {
  std::map<int, const char*>::const_iterator it = _instruction_type_VALUES_TO_NAMES.find(val);
  if (it != _instruction_type_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kedge_kindValues[] = {
  edge_kind::normal,
  edge_kind::call,
  edge_kind::ret,
  edge_kind::go_to
};
const char* _kedge_kindNames[] = {
  "normal",
  "call",
  "ret",
  "go_to"
};
const std::map<int, const char*> _edge_kind_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kedge_kindValues, _kedge_kindNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const edge_kind::type& val) {
  std::map<int, const char*>::const_iterator it = _edge_kind_VALUES_TO_NAMES.find(val);
  if (it != _edge_kind_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const edge_kind::type& val) {
  std::map<int, const char*>::const_iterator it = _edge_kind_VALUES_TO_NAMES.find(val);
  if (it != _edge_kind_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


NoSuchMethod::~NoSuchMethod() noexcept {
}


void NoSuchMethod::__set_method(const std::string& val) {
  this->method = val;
}
std::ostream& operator<<(std::ostream& out, const NoSuchMethod& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchMethod::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->method);
          this->__isset.method = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchMethod::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchMethod");

  xfer += oprot->writeFieldBegin("method", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->method);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchMethod &a, NoSuchMethod &b) {
  using ::std::swap;
  swap(a.method, b.method);
  swap(a.__isset, b.__isset);
}

NoSuchMethod::NoSuchMethod(const NoSuchMethod& other0) : TException() {
  method = other0.method;
  __isset = other0.__isset;
}
NoSuchMethod& NoSuchMethod::operator=(const NoSuchMethod& other1) {
  method = other1.method;
  __isset = other1.__isset;
  return *this;
}
void NoSuchMethod::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchMethod(";
  out << "method=" << to_string(method);
  out << ")";
}

const char* NoSuchMethod::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchMethod";
  }
}


basic_instruction::~basic_instruction() noexcept {
}


void basic_instruction::__set_instruction_id(const id_t& val) {
  this->instruction_id = val;
}

void basic_instruction::__set_method_id(const id_t& val) {
  this->method_id = val;
}

void basic_instruction::__set_representation(const std::string& val) {
  this->representation = val;
}

void basic_instruction::__set_instr_type(const instruction_type::type val) {
  this->instr_type = val;
}

void basic_instruction::__set_json(const std::string& val) {
  this->json = val;
__isset.json = true;
}
std::ostream& operator<<(std::ostream& out, const basic_instruction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t basic_instruction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->instruction_id);
          this->__isset.instruction_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->method_id);
          this->__isset.method_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->representation);
          this->__isset.representation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->instr_type = (instruction_type::type)ecast2;
          this->__isset.instr_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->json);
          this->__isset.json = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t basic_instruction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("basic_instruction");

  xfer += oprot->writeFieldBegin("instruction_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->instruction_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("method_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->method_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("representation", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->representation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("instr_type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->instr_type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.json) {
    xfer += oprot->writeFieldBegin("json", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->json);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(basic_instruction &a, basic_instruction &b) {
  using ::std::swap;
  swap(a.instruction_id, b.instruction_id);
  swap(a.method_id, b.method_id);
  swap(a.representation, b.representation);
  swap(a.instr_type, b.instr_type);
  swap(a.json, b.json);
  swap(a.__isset, b.__isset);
}

basic_instruction::basic_instruction(const basic_instruction& other3) {
  instruction_id = other3.instruction_id;
  method_id = other3.method_id;
  representation = other3.representation;
  instr_type = other3.instr_type;
  json = other3.json;
  __isset = other3.__isset;
}
basic_instruction& basic_instruction::operator=(const basic_instruction& other4) {
  instruction_id = other4.instruction_id;
  method_id = other4.method_id;
  representation = other4.representation;
  instr_type = other4.instr_type;
  json = other4.json;
  __isset = other4.__isset;
  return *this;
}
void basic_instruction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "basic_instruction(";
  out << "instruction_id=" << to_string(instruction_id);
  out << ", " << "method_id=" << to_string(method_id);
  out << ", " << "representation=" << to_string(representation);
  out << ", " << "instr_type=" << to_string(instr_type);
  out << ", " << "json="; (__isset.json ? (out << to_string(json)) : (out << "<null>"));
  out << ")";
}


method::~method() noexcept {
}


void method::__set_method_id(const id_t& val) {
  this->method_id = val;
}

void method::__set_instructions(const std::set<basic_instruction> & val) {
  this->instructions = val;
}

void method::__set_edges(const std::set<edge> & val) {
  this->edges = val;
}

void method::__set_may_fail(const bool val) {
  this->may_fail = val;
}
std::ostream& operator<<(std::ostream& out, const method& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t method::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->method_id);
          this->__isset.method_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->instructions.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readSetBegin(_etype8, _size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              basic_instruction _elem10;
              xfer += _elem10.read(iprot);
              this->instructions.insert(_elem10);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.instructions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->edges.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readSetBegin(_etype14, _size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              edge _elem16;
              xfer += _elem16.read(iprot);
              this->edges.insert(_elem16);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.edges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->may_fail);
          this->__isset.may_fail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t method::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("method");

  xfer += oprot->writeFieldBegin("method_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->method_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("instructions", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->instructions.size()));
    std::set<basic_instruction> ::const_iterator _iter17;
    for (_iter17 = this->instructions.begin(); _iter17 != this->instructions.end(); ++_iter17)
    {
      xfer += (*_iter17).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("edges", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->edges.size()));
    std::set<edge> ::const_iterator _iter18;
    for (_iter18 = this->edges.begin(); _iter18 != this->edges.end(); ++_iter18)
    {
      xfer += (*_iter18).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("may_fail", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->may_fail);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(method &a, method &b) {
  using ::std::swap;
  swap(a.method_id, b.method_id);
  swap(a.instructions, b.instructions);
  swap(a.edges, b.edges);
  swap(a.may_fail, b.may_fail);
  swap(a.__isset, b.__isset);
}

method::method(const method& other19) {
  method_id = other19.method_id;
  instructions = other19.instructions;
  edges = other19.edges;
  may_fail = other19.may_fail;
  __isset = other19.__isset;
}
method& method::operator=(const method& other20) {
  method_id = other20.method_id;
  instructions = other20.instructions;
  edges = other20.edges;
  may_fail = other20.may_fail;
  __isset = other20.__isset;
  return *this;
}
void method::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "method(";
  out << "method_id=" << to_string(method_id);
  out << ", " << "instructions=" << to_string(instructions);
  out << ", " << "edges=" << to_string(edges);
  out << ", " << "may_fail=" << to_string(may_fail);
  out << ")";
}


edge::~edge() noexcept {
}


void edge::__set_source(const id_t& val) {
  this->source = val;
}

void edge::__set_sourceMethod(const id_t& val) {
  this->sourceMethod = val;
}

void edge::__set_target(const id_t& val) {
  this->target = val;
}

void edge::__set_targetMethod(const id_t& val) {
  this->targetMethod = val;
}

void edge::__set_kind(const edge_kind::type val) {
  this->kind = val;
__isset.kind = true;
}
std::ostream& operator<<(std::ostream& out, const edge& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t edge::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->source);
          this->__isset.source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sourceMethod);
          this->__isset.sourceMethod = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->target);
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->targetMethod);
          this->__isset.targetMethod = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast21;
          xfer += iprot->readI32(ecast21);
          this->kind = (edge_kind::type)ecast21;
          this->__isset.kind = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t edge::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("edge");

  xfer += oprot->writeFieldBegin("source", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->source);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sourceMethod", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sourceMethod);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targetMethod", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->targetMethod);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.kind) {
    xfer += oprot->writeFieldBegin("kind", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->kind);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(edge &a, edge &b) {
  using ::std::swap;
  swap(a.source, b.source);
  swap(a.sourceMethod, b.sourceMethod);
  swap(a.target, b.target);
  swap(a.targetMethod, b.targetMethod);
  swap(a.kind, b.kind);
  swap(a.__isset, b.__isset);
}

edge::edge(const edge& other22) {
  source = other22.source;
  sourceMethod = other22.sourceMethod;
  target = other22.target;
  targetMethod = other22.targetMethod;
  kind = other22.kind;
  __isset = other22.__isset;
}
edge& edge::operator=(const edge& other23) {
  source = other23.source;
  sourceMethod = other23.sourceMethod;
  target = other23.target;
  targetMethod = other23.targetMethod;
  kind = other23.kind;
  __isset = other23.__isset;
  return *this;
}
void edge::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "edge(";
  out << "source=" << to_string(source);
  out << ", " << "sourceMethod=" << to_string(sourceMethod);
  out << ", " << "target=" << to_string(target);
  out << ", " << "targetMethod=" << to_string(targetMethod);
  out << ", " << "kind="; (__isset.kind ? (out << to_string(kind)) : (out << "<null>"));
  out << ")";
}


method_info::~method_info() noexcept {
}


void method_info::__set_method_id(const id_t& val) {
  this->method_id = val;
}

void method_info::__set_repr(const std::string& val) {
  this->repr = val;
}
std::ostream& operator<<(std::ostream& out, const method_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t method_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->method_id);
          this->__isset.method_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->repr);
          this->__isset.repr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t method_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("method_info");

  xfer += oprot->writeFieldBegin("method_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->method_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("repr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->repr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(method_info &a, method_info &b) {
  using ::std::swap;
  swap(a.method_id, b.method_id);
  swap(a.repr, b.repr);
  swap(a.__isset, b.__isset);
}

method_info::method_info(const method_info& other24) {
  method_id = other24.method_id;
  repr = other24.repr;
  __isset = other24.__isset;
}
method_info& method_info::operator=(const method_info& other25) {
  method_id = other25.method_id;
  repr = other25.repr;
  __isset = other25.__isset;
  return *this;
}
void method_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "method_info(";
  out << "method_id=" << to_string(method_id);
  out << ", " << "repr=" << to_string(repr);
  out << ")";
}

} // namespace
